// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zkp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zkp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zkp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "crypto-curve/curve_point.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zkp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zkp_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zkp_2eproto;
namespace safeheron {
namespace proto {
class AliceRangeProof;
class AliceRangeProofDefaultTypeInternal;
extern AliceRangeProofDefaultTypeInternal _AliceRangeProof_default_instance_;
class DLNProof;
class DLNProofDefaultTypeInternal;
extern DLNProofDefaultTypeInternal _DLNProof_default_instance_;
class DLogProof;
class DLogProofDefaultTypeInternal;
extern DLogProofDefaultTypeInternal _DLogProof_default_instance_;
class HegProof;
class HegProofDefaultTypeInternal;
extern HegProofDefaultTypeInternal _HegProof_default_instance_;
class PailProof;
class PailProofDefaultTypeInternal;
extern PailProofDefaultTypeInternal _PailProof_default_instance_;
}  // namespace proto
}  // namespace safeheron
PROTOBUF_NAMESPACE_OPEN
template<> ::safeheron::proto::AliceRangeProof* Arena::CreateMaybeMessage<::safeheron::proto::AliceRangeProof>(Arena*);
template<> ::safeheron::proto::DLNProof* Arena::CreateMaybeMessage<::safeheron::proto::DLNProof>(Arena*);
template<> ::safeheron::proto::DLogProof* Arena::CreateMaybeMessage<::safeheron::proto::DLogProof>(Arena*);
template<> ::safeheron::proto::HegProof* Arena::CreateMaybeMessage<::safeheron::proto::HegProof>(Arena*);
template<> ::safeheron::proto::PailProof* Arena::CreateMaybeMessage<::safeheron::proto::PailProof>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safeheron {
namespace proto {

// ===================================================================

class DLogProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.DLogProof) */ {
 public:
  inline DLogProof() : DLogProof(nullptr) {}
  virtual ~DLogProof();

  DLogProof(const DLogProof& from);
  DLogProof(DLogProof&& from) noexcept
    : DLogProof() {
    *this = ::std::move(from);
  }

  inline DLogProof& operator=(const DLogProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline DLogProof& operator=(DLogProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DLogProof& default_instance();

  static inline const DLogProof* internal_default_instance() {
    return reinterpret_cast<const DLogProof*>(
               &_DLogProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DLogProof& a, DLogProof& b) {
    a.Swap(&b);
  }
  inline void Swap(DLogProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DLogProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DLogProof* New() const final {
    return CreateMaybeMessage<DLogProof>(nullptr);
  }

  DLogProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DLogProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DLogProof& from);
  void MergeFrom(const DLogProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DLogProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.DLogProof";
  }
  protected:
  explicit DLogProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zkp_2eproto);
    return ::descriptor_table_zkp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResFieldNumber = 3,
    kPkFieldNumber = 1,
    kGRFieldNumber = 2,
  };
  // string res = 3;
  void clear_res();
  const std::string& res() const;
  void set_res(const std::string& value);
  void set_res(std::string&& value);
  void set_res(const char* value);
  void set_res(const char* value, size_t size);
  std::string* mutable_res();
  std::string* release_res();
  void set_allocated_res(std::string* res);
  private:
  const std::string& _internal_res() const;
  void _internal_set_res(const std::string& value);
  std::string* _internal_mutable_res();
  public:

  // .safeheron.proto.CurvePoint pk = 1;
  bool has_pk() const;
  private:
  bool _internal_has_pk() const;
  public:
  void clear_pk();
  const ::safeheron::proto::CurvePoint& pk() const;
  ::safeheron::proto::CurvePoint* release_pk();
  ::safeheron::proto::CurvePoint* mutable_pk();
  void set_allocated_pk(::safeheron::proto::CurvePoint* pk);
  private:
  const ::safeheron::proto::CurvePoint& _internal_pk() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_pk();
  public:
  void unsafe_arena_set_allocated_pk(
      ::safeheron::proto::CurvePoint* pk);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_pk();

  // .safeheron.proto.CurvePoint g_r = 2;
  bool has_g_r() const;
  private:
  bool _internal_has_g_r() const;
  public:
  void clear_g_r();
  const ::safeheron::proto::CurvePoint& g_r() const;
  ::safeheron::proto::CurvePoint* release_g_r();
  ::safeheron::proto::CurvePoint* mutable_g_r();
  void set_allocated_g_r(::safeheron::proto::CurvePoint* g_r);
  private:
  const ::safeheron::proto::CurvePoint& _internal_g_r() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_g_r();
  public:
  void unsafe_arena_set_allocated_g_r(
      ::safeheron::proto::CurvePoint* g_r);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_g_r();

  // @@protoc_insertion_point(class_scope:safeheron.proto.DLogProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr res_;
  ::safeheron::proto::CurvePoint* pk_;
  ::safeheron::proto::CurvePoint* g_r_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class HegProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.HegProof) */ {
 public:
  inline HegProof() : HegProof(nullptr) {}
  virtual ~HegProof();

  HegProof(const HegProof& from);
  HegProof(HegProof&& from) noexcept
    : HegProof() {
    *this = ::std::move(from);
  }

  inline HegProof& operator=(const HegProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline HegProof& operator=(HegProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HegProof& default_instance();

  static inline const HegProof* internal_default_instance() {
    return reinterpret_cast<const HegProof*>(
               &_HegProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HegProof& a, HegProof& b) {
    a.Swap(&b);
  }
  inline void Swap(HegProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HegProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HegProof* New() const final {
    return CreateMaybeMessage<HegProof>(nullptr);
  }

  HegProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HegProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HegProof& from);
  void MergeFrom(const HegProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HegProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.HegProof";
  }
  protected:
  explicit HegProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zkp_2eproto);
    return ::descriptor_table_zkp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZ1FieldNumber = 3,
    kZ2FieldNumber = 4,
    kTFieldNumber = 1,
    kA3FieldNumber = 2,
  };
  // string z1 = 3;
  void clear_z1();
  const std::string& z1() const;
  void set_z1(const std::string& value);
  void set_z1(std::string&& value);
  void set_z1(const char* value);
  void set_z1(const char* value, size_t size);
  std::string* mutable_z1();
  std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string z2 = 4;
  void clear_z2();
  const std::string& z2() const;
  void set_z2(const std::string& value);
  void set_z2(std::string&& value);
  void set_z2(const char* value);
  void set_z2(const char* value, size_t size);
  std::string* mutable_z2();
  std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // .safeheron.proto.CurvePoint T = 1;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  const ::safeheron::proto::CurvePoint& t() const;
  ::safeheron::proto::CurvePoint* release_t();
  ::safeheron::proto::CurvePoint* mutable_t();
  void set_allocated_t(::safeheron::proto::CurvePoint* t);
  private:
  const ::safeheron::proto::CurvePoint& _internal_t() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::safeheron::proto::CurvePoint* t);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_t();

  // .safeheron.proto.CurvePoint A3 = 2;
  bool has_a3() const;
  private:
  bool _internal_has_a3() const;
  public:
  void clear_a3();
  const ::safeheron::proto::CurvePoint& a3() const;
  ::safeheron::proto::CurvePoint* release_a3();
  ::safeheron::proto::CurvePoint* mutable_a3();
  void set_allocated_a3(::safeheron::proto::CurvePoint* a3);
  private:
  const ::safeheron::proto::CurvePoint& _internal_a3() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_a3();
  public:
  void unsafe_arena_set_allocated_a3(
      ::safeheron::proto::CurvePoint* a3);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_a3();

  // @@protoc_insertion_point(class_scope:safeheron.proto.HegProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::safeheron::proto::CurvePoint* t_;
  ::safeheron::proto::CurvePoint* a3_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailProof) */ {
 public:
  inline PailProof() : PailProof(nullptr) {}
  virtual ~PailProof();

  PailProof(const PailProof& from);
  PailProof(PailProof&& from) noexcept
    : PailProof() {
    *this = ::std::move(from);
  }

  inline PailProof& operator=(const PailProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailProof& operator=(PailProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PailProof& default_instance();

  static inline const PailProof* internal_default_instance() {
    return reinterpret_cast<const PailProof*>(
               &_PailProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PailProof& a, PailProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PailProof* New() const final {
    return CreateMaybeMessage<PailProof>(nullptr);
  }

  PailProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PailProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PailProof& from);
  void MergeFrom(const PailProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailProof";
  }
  protected:
  explicit PailProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zkp_2eproto);
    return ::descriptor_table_zkp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYNArrFieldNumber = 1,
  };
  // repeated string y_N_arr = 1;
  int y_n_arr_size() const;
  private:
  int _internal_y_n_arr_size() const;
  public:
  void clear_y_n_arr();
  const std::string& y_n_arr(int index) const;
  std::string* mutable_y_n_arr(int index);
  void set_y_n_arr(int index, const std::string& value);
  void set_y_n_arr(int index, std::string&& value);
  void set_y_n_arr(int index, const char* value);
  void set_y_n_arr(int index, const char* value, size_t size);
  std::string* add_y_n_arr();
  void add_y_n_arr(const std::string& value);
  void add_y_n_arr(std::string&& value);
  void add_y_n_arr(const char* value);
  void add_y_n_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& y_n_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_y_n_arr();
  private:
  const std::string& _internal_y_n_arr(int index) const;
  std::string* _internal_add_y_n_arr();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> y_n_arr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class AliceRangeProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.AliceRangeProof) */ {
 public:
  inline AliceRangeProof() : AliceRangeProof(nullptr) {}
  virtual ~AliceRangeProof();

  AliceRangeProof(const AliceRangeProof& from);
  AliceRangeProof(AliceRangeProof&& from) noexcept
    : AliceRangeProof() {
    *this = ::std::move(from);
  }

  inline AliceRangeProof& operator=(const AliceRangeProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline AliceRangeProof& operator=(AliceRangeProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AliceRangeProof& default_instance();

  static inline const AliceRangeProof* internal_default_instance() {
    return reinterpret_cast<const AliceRangeProof*>(
               &_AliceRangeProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AliceRangeProof& a, AliceRangeProof& b) {
    a.Swap(&b);
  }
  inline void Swap(AliceRangeProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AliceRangeProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AliceRangeProof* New() const final {
    return CreateMaybeMessage<AliceRangeProof>(nullptr);
  }

  AliceRangeProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AliceRangeProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AliceRangeProof& from);
  void MergeFrom(const AliceRangeProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AliceRangeProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.AliceRangeProof";
  }
  protected:
  explicit AliceRangeProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zkp_2eproto);
    return ::descriptor_table_zkp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 1,
    kUFieldNumber = 2,
    kWFieldNumber = 3,
    kSFieldNumber = 4,
    kS1FieldNumber = 5,
    kS2FieldNumber = 6,
  };
  // string z = 1;
  void clear_z();
  const std::string& z() const;
  void set_z(const std::string& value);
  void set_z(std::string&& value);
  void set_z(const char* value);
  void set_z(const char* value, size_t size);
  std::string* mutable_z();
  std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string u = 2;
  void clear_u();
  const std::string& u() const;
  void set_u(const std::string& value);
  void set_u(std::string&& value);
  void set_u(const char* value);
  void set_u(const char* value, size_t size);
  std::string* mutable_u();
  std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // string w = 3;
  void clear_w();
  const std::string& w() const;
  void set_w(const std::string& value);
  void set_w(std::string&& value);
  void set_w(const char* value);
  void set_w(const char* value, size_t size);
  std::string* mutable_w();
  std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // string s = 4;
  void clear_s();
  const std::string& s() const;
  void set_s(const std::string& value);
  void set_s(std::string&& value);
  void set_s(const char* value);
  void set_s(const char* value, size_t size);
  std::string* mutable_s();
  std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string s1 = 5;
  void clear_s1();
  const std::string& s1() const;
  void set_s1(const std::string& value);
  void set_s1(std::string&& value);
  void set_s1(const char* value);
  void set_s1(const char* value, size_t size);
  std::string* mutable_s1();
  std::string* release_s1();
  void set_allocated_s1(std::string* s1);
  private:
  const std::string& _internal_s1() const;
  void _internal_set_s1(const std::string& value);
  std::string* _internal_mutable_s1();
  public:

  // string s2 = 6;
  void clear_s2();
  const std::string& s2() const;
  void set_s2(const std::string& value);
  void set_s2(std::string&& value);
  void set_s2(const char* value);
  void set_s2(const char* value, size_t size);
  std::string* mutable_s2();
  std::string* release_s2();
  void set_allocated_s2(std::string* s2);
  private:
  const std::string& _internal_s2() const;
  void _internal_set_s2(const std::string& value);
  std::string* _internal_mutable_s2();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.AliceRangeProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class DLNProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.DLNProof) */ {
 public:
  inline DLNProof() : DLNProof(nullptr) {}
  virtual ~DLNProof();

  DLNProof(const DLNProof& from);
  DLNProof(DLNProof&& from) noexcept
    : DLNProof() {
    *this = ::std::move(from);
  }

  inline DLNProof& operator=(const DLNProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline DLNProof& operator=(DLNProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DLNProof& default_instance();

  static inline const DLNProof* internal_default_instance() {
    return reinterpret_cast<const DLNProof*>(
               &_DLNProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DLNProof& a, DLNProof& b) {
    a.Swap(&b);
  }
  inline void Swap(DLNProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DLNProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DLNProof* New() const final {
    return CreateMaybeMessage<DLNProof>(nullptr);
  }

  DLNProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DLNProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DLNProof& from);
  void MergeFrom(const DLNProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DLNProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.DLNProof";
  }
  protected:
  explicit DLNProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zkp_2eproto);
    return ::descriptor_table_zkp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlphaArrFieldNumber = 1,
    kTArrFieldNumber = 2,
  };
  // repeated string alpha_arr = 1;
  int alpha_arr_size() const;
  private:
  int _internal_alpha_arr_size() const;
  public:
  void clear_alpha_arr();
  const std::string& alpha_arr(int index) const;
  std::string* mutable_alpha_arr(int index);
  void set_alpha_arr(int index, const std::string& value);
  void set_alpha_arr(int index, std::string&& value);
  void set_alpha_arr(int index, const char* value);
  void set_alpha_arr(int index, const char* value, size_t size);
  std::string* add_alpha_arr();
  void add_alpha_arr(const std::string& value);
  void add_alpha_arr(std::string&& value);
  void add_alpha_arr(const char* value);
  void add_alpha_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& alpha_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_alpha_arr();
  private:
  const std::string& _internal_alpha_arr(int index) const;
  std::string* _internal_add_alpha_arr();
  public:

  // repeated string t_arr = 2;
  int t_arr_size() const;
  private:
  int _internal_t_arr_size() const;
  public:
  void clear_t_arr();
  const std::string& t_arr(int index) const;
  std::string* mutable_t_arr(int index);
  void set_t_arr(int index, const std::string& value);
  void set_t_arr(int index, std::string&& value);
  void set_t_arr(int index, const char* value);
  void set_t_arr(int index, const char* value, size_t size);
  std::string* add_t_arr();
  void add_t_arr(const std::string& value);
  void add_t_arr(std::string&& value);
  void add_t_arr(const char* value);
  void add_t_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& t_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_t_arr();
  private:
  const std::string& _internal_t_arr(int index) const;
  std::string* _internal_add_t_arr();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.DLNProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> alpha_arr_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> t_arr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DLogProof

// .safeheron.proto.CurvePoint pk = 1;
inline bool DLogProof::_internal_has_pk() const {
  return this != internal_default_instance() && pk_ != nullptr;
}
inline bool DLogProof::has_pk() const {
  return _internal_has_pk();
}
inline const ::safeheron::proto::CurvePoint& DLogProof::_internal_pk() const {
  const ::safeheron::proto::CurvePoint* p = pk_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DLogProof::pk() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLogProof.pk)
  return _internal_pk();
}
inline void DLogProof::unsafe_arena_set_allocated_pk(
    ::safeheron::proto::CurvePoint* pk) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pk_);
  }
  pk_ = pk;
  if (pk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DLogProof.pk)
}
inline ::safeheron::proto::CurvePoint* DLogProof::release_pk() {
  
  ::safeheron::proto::CurvePoint* temp = pk_;
  pk_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof::unsafe_arena_release_pk() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DLogProof.pk)
  
  ::safeheron::proto::CurvePoint* temp = pk_;
  pk_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof::_internal_mutable_pk() {
  
  if (pk_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArena());
    pk_ = p;
  }
  return pk_;
}
inline ::safeheron::proto::CurvePoint* DLogProof::mutable_pk() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLogProof.pk)
  return _internal_mutable_pk();
}
inline void DLogProof::set_allocated_pk(::safeheron::proto::CurvePoint* pk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pk_);
  }
  if (pk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pk)->GetArena();
    if (message_arena != submessage_arena) {
      pk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pk, submessage_arena);
    }
    
  } else {
    
  }
  pk_ = pk;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DLogProof.pk)
}

// .safeheron.proto.CurvePoint g_r = 2;
inline bool DLogProof::_internal_has_g_r() const {
  return this != internal_default_instance() && g_r_ != nullptr;
}
inline bool DLogProof::has_g_r() const {
  return _internal_has_g_r();
}
inline const ::safeheron::proto::CurvePoint& DLogProof::_internal_g_r() const {
  const ::safeheron::proto::CurvePoint* p = g_r_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DLogProof::g_r() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLogProof.g_r)
  return _internal_g_r();
}
inline void DLogProof::unsafe_arena_set_allocated_g_r(
    ::safeheron::proto::CurvePoint* g_r) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(g_r_);
  }
  g_r_ = g_r;
  if (g_r) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DLogProof.g_r)
}
inline ::safeheron::proto::CurvePoint* DLogProof::release_g_r() {
  
  ::safeheron::proto::CurvePoint* temp = g_r_;
  g_r_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof::unsafe_arena_release_g_r() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DLogProof.g_r)
  
  ::safeheron::proto::CurvePoint* temp = g_r_;
  g_r_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof::_internal_mutable_g_r() {
  
  if (g_r_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArena());
    g_r_ = p;
  }
  return g_r_;
}
inline ::safeheron::proto::CurvePoint* DLogProof::mutable_g_r() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLogProof.g_r)
  return _internal_mutable_g_r();
}
inline void DLogProof::set_allocated_g_r(::safeheron::proto::CurvePoint* g_r) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(g_r_);
  }
  if (g_r) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(g_r)->GetArena();
    if (message_arena != submessage_arena) {
      g_r = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, g_r, submessage_arena);
    }
    
  } else {
    
  }
  g_r_ = g_r;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DLogProof.g_r)
}

// string res = 3;
inline void DLogProof::clear_res() {
  res_.ClearToEmpty();
}
inline const std::string& DLogProof::res() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLogProof.res)
  return _internal_res();
}
inline void DLogProof::set_res(const std::string& value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.DLogProof.res)
}
inline std::string* DLogProof::mutable_res() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLogProof.res)
  return _internal_mutable_res();
}
inline const std::string& DLogProof::_internal_res() const {
  return res_.Get();
}
inline void DLogProof::_internal_set_res(const std::string& value) {
  
  res_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DLogProof::set_res(std::string&& value) {
  
  res_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.DLogProof.res)
}
inline void DLogProof::set_res(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  res_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.DLogProof.res)
}
inline void DLogProof::set_res(const char* value,
    size_t size) {
  
  res_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.DLogProof.res)
}
inline std::string* DLogProof::_internal_mutable_res() {
  
  return res_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DLogProof::release_res() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DLogProof.res)
  return res_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DLogProof::set_allocated_res(std::string* res) {
  if (res != nullptr) {
    
  } else {
    
  }
  res_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), res,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DLogProof.res)
}

// -------------------------------------------------------------------

// HegProof

// .safeheron.proto.CurvePoint T = 1;
inline bool HegProof::_internal_has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline bool HegProof::has_t() const {
  return _internal_has_t();
}
inline const ::safeheron::proto::CurvePoint& HegProof::_internal_t() const {
  const ::safeheron::proto::CurvePoint* p = t_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& HegProof::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HegProof.T)
  return _internal_t();
}
inline void HegProof::unsafe_arena_set_allocated_t(
    ::safeheron::proto::CurvePoint* t) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_);
  }
  t_ = t;
  if (t) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.HegProof.T)
}
inline ::safeheron::proto::CurvePoint* HegProof::release_t() {
  
  ::safeheron::proto::CurvePoint* temp = t_;
  t_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::safeheron::proto::CurvePoint* HegProof::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HegProof.T)
  
  ::safeheron::proto::CurvePoint* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* HegProof::_internal_mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArena());
    t_ = p;
  }
  return t_;
}
inline ::safeheron::proto::CurvePoint* HegProof::mutable_t() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HegProof.T)
  return _internal_mutable_t();
}
inline void HegProof::set_allocated_t(::safeheron::proto::CurvePoint* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_);
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t)->GetArena();
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HegProof.T)
}

// .safeheron.proto.CurvePoint A3 = 2;
inline bool HegProof::_internal_has_a3() const {
  return this != internal_default_instance() && a3_ != nullptr;
}
inline bool HegProof::has_a3() const {
  return _internal_has_a3();
}
inline const ::safeheron::proto::CurvePoint& HegProof::_internal_a3() const {
  const ::safeheron::proto::CurvePoint* p = a3_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& HegProof::a3() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HegProof.A3)
  return _internal_a3();
}
inline void HegProof::unsafe_arena_set_allocated_a3(
    ::safeheron::proto::CurvePoint* a3) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a3_);
  }
  a3_ = a3;
  if (a3) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.HegProof.A3)
}
inline ::safeheron::proto::CurvePoint* HegProof::release_a3() {
  
  ::safeheron::proto::CurvePoint* temp = a3_;
  a3_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::safeheron::proto::CurvePoint* HegProof::unsafe_arena_release_a3() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HegProof.A3)
  
  ::safeheron::proto::CurvePoint* temp = a3_;
  a3_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* HegProof::_internal_mutable_a3() {
  
  if (a3_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArena());
    a3_ = p;
  }
  return a3_;
}
inline ::safeheron::proto::CurvePoint* HegProof::mutable_a3() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HegProof.A3)
  return _internal_mutable_a3();
}
inline void HegProof::set_allocated_a3(::safeheron::proto::CurvePoint* a3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(a3_);
  }
  if (a3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a3)->GetArena();
    if (message_arena != submessage_arena) {
      a3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a3, submessage_arena);
    }
    
  } else {
    
  }
  a3_ = a3;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HegProof.A3)
}

// string z1 = 3;
inline void HegProof::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& HegProof::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HegProof.z1)
  return _internal_z1();
}
inline void HegProof::set_z1(const std::string& value) {
  _internal_set_z1(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.HegProof.z1)
}
inline std::string* HegProof::mutable_z1() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HegProof.z1)
  return _internal_mutable_z1();
}
inline const std::string& HegProof::_internal_z1() const {
  return z1_.Get();
}
inline void HegProof::_internal_set_z1(const std::string& value) {
  
  z1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HegProof::set_z1(std::string&& value) {
  
  z1_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.HegProof.z1)
}
inline void HegProof::set_z1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  z1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.HegProof.z1)
}
inline void HegProof::set_z1(const char* value,
    size_t size) {
  
  z1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.HegProof.z1)
}
inline std::string* HegProof::_internal_mutable_z1() {
  
  return z1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HegProof::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HegProof.z1)
  return z1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HegProof::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), z1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HegProof.z1)
}

// string z2 = 4;
inline void HegProof::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& HegProof::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HegProof.z2)
  return _internal_z2();
}
inline void HegProof::set_z2(const std::string& value) {
  _internal_set_z2(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.HegProof.z2)
}
inline std::string* HegProof::mutable_z2() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HegProof.z2)
  return _internal_mutable_z2();
}
inline const std::string& HegProof::_internal_z2() const {
  return z2_.Get();
}
inline void HegProof::_internal_set_z2(const std::string& value) {
  
  z2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HegProof::set_z2(std::string&& value) {
  
  z2_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.HegProof.z2)
}
inline void HegProof::set_z2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  z2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.HegProof.z2)
}
inline void HegProof::set_z2(const char* value,
    size_t size) {
  
  z2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.HegProof.z2)
}
inline std::string* HegProof::_internal_mutable_z2() {
  
  return z2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HegProof::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HegProof.z2)
  return z2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HegProof::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), z2,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HegProof.z2)
}

// -------------------------------------------------------------------

// PailProof

// repeated string y_N_arr = 1;
inline int PailProof::_internal_y_n_arr_size() const {
  return y_n_arr_.size();
}
inline int PailProof::y_n_arr_size() const {
  return _internal_y_n_arr_size();
}
inline void PailProof::clear_y_n_arr() {
  y_n_arr_.Clear();
}
inline std::string* PailProof::add_y_n_arr() {
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.PailProof.y_N_arr)
  return _internal_add_y_n_arr();
}
inline const std::string& PailProof::_internal_y_n_arr(int index) const {
  return y_n_arr_.Get(index);
}
inline const std::string& PailProof::y_n_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailProof.y_N_arr)
  return _internal_y_n_arr(index);
}
inline std::string* PailProof::mutable_y_n_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailProof.y_N_arr)
  return y_n_arr_.Mutable(index);
}
inline void PailProof::set_y_n_arr(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.PailProof.y_N_arr)
  y_n_arr_.Mutable(index)->assign(value);
}
inline void PailProof::set_y_n_arr(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.PailProof.y_N_arr)
  y_n_arr_.Mutable(index)->assign(std::move(value));
}
inline void PailProof::set_y_n_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_n_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::set_y_n_arr(int index, const char* value, size_t size) {
  y_n_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.PailProof.y_N_arr)
}
inline std::string* PailProof::_internal_add_y_n_arr() {
  return y_n_arr_.Add();
}
inline void PailProof::add_y_n_arr(const std::string& value) {
  y_n_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::add_y_n_arr(std::string&& value) {
  y_n_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::add_y_n_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_n_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::add_y_n_arr(const char* value, size_t size) {
  y_n_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.PailProof.y_N_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PailProof::y_n_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailProof.y_N_arr)
  return y_n_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PailProof::mutable_y_n_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailProof.y_N_arr)
  return &y_n_arr_;
}

// -------------------------------------------------------------------

// AliceRangeProof

// string z = 1;
inline void AliceRangeProof::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.z)
  return _internal_z();
}
inline void AliceRangeProof::set_z(const std::string& value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.z)
}
inline std::string* AliceRangeProof::mutable_z() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.z)
  return _internal_mutable_z();
}
inline const std::string& AliceRangeProof::_internal_z() const {
  return z_.Get();
}
inline void AliceRangeProof::_internal_set_z(const std::string& value) {
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AliceRangeProof::set_z(std::string&& value) {
  
  z_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.AliceRangeProof.z)
}
inline void AliceRangeProof::set_z(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.AliceRangeProof.z)
}
inline void AliceRangeProof::set_z(const char* value,
    size_t size) {
  
  z_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.AliceRangeProof.z)
}
inline std::string* AliceRangeProof::_internal_mutable_z() {
  
  return z_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AliceRangeProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.z)
  return z_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AliceRangeProof::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), z,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.z)
}

// string u = 2;
inline void AliceRangeProof::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.u)
  return _internal_u();
}
inline void AliceRangeProof::set_u(const std::string& value) {
  _internal_set_u(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.u)
}
inline std::string* AliceRangeProof::mutable_u() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.u)
  return _internal_mutable_u();
}
inline const std::string& AliceRangeProof::_internal_u() const {
  return u_.Get();
}
inline void AliceRangeProof::_internal_set_u(const std::string& value) {
  
  u_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AliceRangeProof::set_u(std::string&& value) {
  
  u_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.AliceRangeProof.u)
}
inline void AliceRangeProof::set_u(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  u_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.AliceRangeProof.u)
}
inline void AliceRangeProof::set_u(const char* value,
    size_t size) {
  
  u_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.AliceRangeProof.u)
}
inline std::string* AliceRangeProof::_internal_mutable_u() {
  
  return u_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AliceRangeProof::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.u)
  return u_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AliceRangeProof::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), u,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.u)
}

// string w = 3;
inline void AliceRangeProof::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.w)
  return _internal_w();
}
inline void AliceRangeProof::set_w(const std::string& value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.w)
}
inline std::string* AliceRangeProof::mutable_w() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.w)
  return _internal_mutable_w();
}
inline const std::string& AliceRangeProof::_internal_w() const {
  return w_.Get();
}
inline void AliceRangeProof::_internal_set_w(const std::string& value) {
  
  w_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AliceRangeProof::set_w(std::string&& value) {
  
  w_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.AliceRangeProof.w)
}
inline void AliceRangeProof::set_w(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  w_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.AliceRangeProof.w)
}
inline void AliceRangeProof::set_w(const char* value,
    size_t size) {
  
  w_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.AliceRangeProof.w)
}
inline std::string* AliceRangeProof::_internal_mutable_w() {
  
  return w_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AliceRangeProof::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.w)
  return w_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AliceRangeProof::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), w,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.w)
}

// string s = 4;
inline void AliceRangeProof::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.s)
  return _internal_s();
}
inline void AliceRangeProof::set_s(const std::string& value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.s)
}
inline std::string* AliceRangeProof::mutable_s() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.s)
  return _internal_mutable_s();
}
inline const std::string& AliceRangeProof::_internal_s() const {
  return s_.Get();
}
inline void AliceRangeProof::_internal_set_s(const std::string& value) {
  
  s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AliceRangeProof::set_s(std::string&& value) {
  
  s_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.AliceRangeProof.s)
}
inline void AliceRangeProof::set_s(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.AliceRangeProof.s)
}
inline void AliceRangeProof::set_s(const char* value,
    size_t size) {
  
  s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.AliceRangeProof.s)
}
inline std::string* AliceRangeProof::_internal_mutable_s() {
  
  return s_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AliceRangeProof::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.s)
  return s_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AliceRangeProof::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.s)
}

// string s1 = 5;
inline void AliceRangeProof::clear_s1() {
  s1_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::s1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.s1)
  return _internal_s1();
}
inline void AliceRangeProof::set_s1(const std::string& value) {
  _internal_set_s1(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.s1)
}
inline std::string* AliceRangeProof::mutable_s1() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.s1)
  return _internal_mutable_s1();
}
inline const std::string& AliceRangeProof::_internal_s1() const {
  return s1_.Get();
}
inline void AliceRangeProof::_internal_set_s1(const std::string& value) {
  
  s1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AliceRangeProof::set_s1(std::string&& value) {
  
  s1_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.AliceRangeProof.s1)
}
inline void AliceRangeProof::set_s1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  s1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.AliceRangeProof.s1)
}
inline void AliceRangeProof::set_s1(const char* value,
    size_t size) {
  
  s1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.AliceRangeProof.s1)
}
inline std::string* AliceRangeProof::_internal_mutable_s1() {
  
  return s1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AliceRangeProof::release_s1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.s1)
  return s1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AliceRangeProof::set_allocated_s1(std::string* s1) {
  if (s1 != nullptr) {
    
  } else {
    
  }
  s1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.s1)
}

// string s2 = 6;
inline void AliceRangeProof::clear_s2() {
  s2_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::s2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.s2)
  return _internal_s2();
}
inline void AliceRangeProof::set_s2(const std::string& value) {
  _internal_set_s2(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.s2)
}
inline std::string* AliceRangeProof::mutable_s2() {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.s2)
  return _internal_mutable_s2();
}
inline const std::string& AliceRangeProof::_internal_s2() const {
  return s2_.Get();
}
inline void AliceRangeProof::_internal_set_s2(const std::string& value) {
  
  s2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AliceRangeProof::set_s2(std::string&& value) {
  
  s2_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.AliceRangeProof.s2)
}
inline void AliceRangeProof::set_s2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  s2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:safeheron.proto.AliceRangeProof.s2)
}
inline void AliceRangeProof::set_s2(const char* value,
    size_t size) {
  
  s2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.AliceRangeProof.s2)
}
inline std::string* AliceRangeProof::_internal_mutable_s2() {
  
  return s2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AliceRangeProof::release_s2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.s2)
  return s2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AliceRangeProof::set_allocated_s2(std::string* s2) {
  if (s2 != nullptr) {
    
  } else {
    
  }
  s2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s2,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.s2)
}

// -------------------------------------------------------------------

// DLNProof

// repeated string alpha_arr = 1;
inline int DLNProof::_internal_alpha_arr_size() const {
  return alpha_arr_.size();
}
inline int DLNProof::alpha_arr_size() const {
  return _internal_alpha_arr_size();
}
inline void DLNProof::clear_alpha_arr() {
  alpha_arr_.Clear();
}
inline std::string* DLNProof::add_alpha_arr() {
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.DLNProof.alpha_arr)
  return _internal_add_alpha_arr();
}
inline const std::string& DLNProof::_internal_alpha_arr(int index) const {
  return alpha_arr_.Get(index);
}
inline const std::string& DLNProof::alpha_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLNProof.alpha_arr)
  return _internal_alpha_arr(index);
}
inline std::string* DLNProof::mutable_alpha_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLNProof.alpha_arr)
  return alpha_arr_.Mutable(index);
}
inline void DLNProof::set_alpha_arr(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.DLNProof.alpha_arr)
  alpha_arr_.Mutable(index)->assign(value);
}
inline void DLNProof::set_alpha_arr(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.DLNProof.alpha_arr)
  alpha_arr_.Mutable(index)->assign(std::move(value));
}
inline void DLNProof::set_alpha_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  alpha_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::set_alpha_arr(int index, const char* value, size_t size) {
  alpha_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.DLNProof.alpha_arr)
}
inline std::string* DLNProof::_internal_add_alpha_arr() {
  return alpha_arr_.Add();
}
inline void DLNProof::add_alpha_arr(const std::string& value) {
  alpha_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::add_alpha_arr(std::string&& value) {
  alpha_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::add_alpha_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  alpha_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::add_alpha_arr(const char* value, size_t size) {
  alpha_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.DLNProof.alpha_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DLNProof::alpha_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.DLNProof.alpha_arr)
  return alpha_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DLNProof::mutable_alpha_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.DLNProof.alpha_arr)
  return &alpha_arr_;
}

// repeated string t_arr = 2;
inline int DLNProof::_internal_t_arr_size() const {
  return t_arr_.size();
}
inline int DLNProof::t_arr_size() const {
  return _internal_t_arr_size();
}
inline void DLNProof::clear_t_arr() {
  t_arr_.Clear();
}
inline std::string* DLNProof::add_t_arr() {
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.DLNProof.t_arr)
  return _internal_add_t_arr();
}
inline const std::string& DLNProof::_internal_t_arr(int index) const {
  return t_arr_.Get(index);
}
inline const std::string& DLNProof::t_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLNProof.t_arr)
  return _internal_t_arr(index);
}
inline std::string* DLNProof::mutable_t_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLNProof.t_arr)
  return t_arr_.Mutable(index);
}
inline void DLNProof::set_t_arr(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.DLNProof.t_arr)
  t_arr_.Mutable(index)->assign(value);
}
inline void DLNProof::set_t_arr(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.DLNProof.t_arr)
  t_arr_.Mutable(index)->assign(std::move(value));
}
inline void DLNProof::set_t_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  t_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::set_t_arr(int index, const char* value, size_t size) {
  t_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.DLNProof.t_arr)
}
inline std::string* DLNProof::_internal_add_t_arr() {
  return t_arr_.Add();
}
inline void DLNProof::add_t_arr(const std::string& value) {
  t_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::add_t_arr(std::string&& value) {
  t_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::add_t_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  t_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::add_t_arr(const char* value, size_t size) {
  t_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.DLNProof.t_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DLNProof::t_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.DLNProof.t_arr)
  return t_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DLNProof::mutable_t_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.DLNProof.t_arr)
  return &t_arr_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace safeheron

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zkp_2eproto
